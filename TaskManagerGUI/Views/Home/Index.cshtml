@{
    ViewData["Title"] = "Home Page";
    var processList = ViewData["ProcessList"] as List<ProcessModel>;
    var memoryList = ViewData["MemoryList"] as List<MemoryModel>;

    @using Newtonsoft.Json;
}


<div class="container">
    <div class="text-center">
        <h2 class="display-4">Task Manager</h2>
        <div class="container">
            <div class="row">
                <div class="col">
                    <canvas id="runningProcessChart" style="max-width:600px;"></canvas>
                </div>
                <div class="col">
                    <h3 style="font-weight: 300;">Memory Status</h3>
                    <canvas id="memoryCheckChart" style="max-width:600px;"></canvas>
                </div>
            </div>
        </div>
    </div>
</div>



<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.4/Chart.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/6.0.1/signalr.js"></script>

<script>
    const connection = new signalR.HubConnectionBuilder()
        .withUrl("/memoryStatsHub")
        .configureLogging(signalR.LogLevel.Information)
        .build();

    async function startConnection() {
        try {
            await connection.start();
            console.log("SignalR Connected");
        } catch (err) {
            console.log(err);
            setTimeout(start, 5000);
        }
    };

    function formatTimeStamp(timestamp) {
        const date = new Date(timestamp);
        const hours = date.getHours().toString().padStart(2, '0');
        const minutes = date.getMinutes().toString().padStart(2, '0');
        const seconds = date.getSeconds().toString().padStart(2, '0');
        
        return `${hours}:${minutes}:${seconds}`;
    }


    connection.on("UpdateMemoryStats", (memoryStats) => {
        console.log("Memory Stats Updated: ", memoryStats);


        const xDates = [];
        const yCounterSamples = [];

        for (const stat of memoryStats) {
            xDates.push(formatTimeStamp(stat['timeStamp']));
            yCounterSamples.push(Number(stat['megaBytes']));
        }

        const chartData = {
            labels: xDates,
            datasets: [{
                data: yCounterSamples,
                label: "Memory Usage (MB)",
                backgroundColor: 'rgba(255, 50, 0, 1)',   
                borderColor: 'rgba(255, 50, 0, 1)',
                fill: 'start'
            }]
        };

        const memoryChart = new Chart("memoryCheckChart", {
            type: 'line',
            data: chartData,
            options: {
                scales: {
                    y: {
                        beginAtZero: true
                    }
                },
                layout: {
                    padding: {
                        left: 20,
                        right: 20,
                        top: 20,
                        bottom: 20
                    }
                }
            }
        });
    });

    connection.onclose(async () => {
        await startConnection();
    });

    startConnection();



</script>


<script>

    
    const processConnection = new signalR.HubConnectionBuilder()
        .withUrl("/processHub")
        .configureLogging(signalR.LogLevel.Information)
        .build();

    async function startConnection() {
        try {
            await processConnection.start();
            console.log("SignalR Connected");
        } catch (err) {
            console.log(err);
            setTimeout(start, 5000);
        }
    }
    

    const xValues = [];
    const yValues = [];

    const randomColors = [
        "#FF0034",
        "#980015",
        "#E1274D",
        "#E71843",
        "#D18F98",
        "#FA4B9A"
    ];

    
    connection.on("UpdateProcesses", (processList) => {
        console.log("Processes Updated: ", processList);
    });
    

    @{
        var highestCpuProcesses = processList.OrderByDescending(p => p.CPU).Take(6).ToList();
    }
    @foreach (var process in highestCpuProcesses)
    {
        <text>
            xValues.push("@process.ProcessName");
            yValues.push(@process.CPU);
        </text>
    }

    const barColors = [];
    const borderColors = [];
    for (let i = 0; i < xValues.length; i += 1)
    {
        const randomColor = randomColors[i]
        barColors.push(randomColor);
        borderColors.push(randomColor);
    }


    new Chart("runningProcessChart", {
        type: "doughnut",
        data: {
            labels: xValues,
            datasets: [{
                backgroundColor: barColors,
                borderColor: borderColors,
                data: yValues
            }]
        },
        options: {
            title: {
                display: true,
                text: "Currently Running Processes"
            },
            legend: {
                display: false
            }
        }
    });
</script>